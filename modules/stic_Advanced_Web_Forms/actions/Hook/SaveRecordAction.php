<?php
/**
 * This file is part of SinergiaCRM.
 * SinergiaCRM is a work developed by SinergiaTIC Association, based on SuiteCRM.
 * Copyright (C) 2013 - 2023 SinergiaTIC Association
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License version 3 as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License along with
 * this program; if not, see http://www.gnu.org/licenses or write to the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 *
 * You can contact SinergiaTIC Association at email address info@sinergiacrm.org.
 */
// Prevents directly accessing this file from a web browser
if (!defined('sugarEntry') || !sugarEntry) {
    die('Not A Valid Entry Point');
}

include_once "modules/stic_Advanced_Web_Forms/actions/coreActions.php";

/**
 * SaveRecordAction
 *
 * Action that manages saving a Data Block to the Database.
 */
class SaveRecordAction extends HookDataBlockActionDefinition {
    public function __construct() {
        $this->isActive = true;
        $this->isUserSelectable = false; // Users cannot select this action manually
        $this->isAutomatic = true;       // The action is automatically generated by the system
        $this->category = 'data';
        $this->baseLabel = 'LBL_SAVE_RECORD_ACTION';
    }

    /**
     * Executes the action, receiving the resolved and validated main data block.
     *
     * @param ExecutionContext $context The global context.
     * @param FormAction $actionConfig The action configuration.
     * @param DataBlockResolved $block The main data block, ready to be used.
     * @return ActionResult
     */
    public function executeWithBlock(ExecutionContext $context, FormAction $actionConfig, DataBlockResolved $block): ActionResult
    {
        global $db;
        $module = $block->dataBlock->module;
        $bean = null;
        $onDuplicateAction = null;

        // Duplicate detection logic
        $duplicateRules = $block->dataBlock->duplicate_detections ?? [];
        foreach ($duplicateRules as $rule) {
            $scalarFields = [];
            $emailValues = [];
            $skipRule = false;

            $foundBean = null;
            $tempBean = BeanFactory::newBean($module);

            // Build the search fields for this rule
            foreach ($rule->fields as $fieldName) {
                $fieldValue = $block->getFieldValue($fieldName)?->value;

                // If a field in the duplicate rule is empty, do not apply the rule
                // (Two persons cannot be the same if both have an empty email field)
                if ($fieldValue === null || $fieldValue === '') {
                    $skipRule = false;
                    break; // Move to the next rule
                }
                if ($this->isEmailField($tempBean, $fieldName)) {
                    $emailValues[] = $fieldValue;
                } else {
                    $scalarFields[$fieldName] = $fieldValue;
                }
            }
            if ($skipRule) {
                continue; // Move to the next rule
            }

            // Email duplicate check
            if (!empty($emailValues)) {
                // Rule includes emails: JOIN with email table
                foreach ($emailValues as $email) {
                    // Query to find IDs that have THIS specific email
                    $sql = "SELECT DISTINCT ebr.bean_id 
                            FROM email_addr_bean_rel ebr
                            INNER JOIN email_addresses ea ON ebr.email_address_id = ea.id
                            WHERE ebr.bean_module = '{$module}'
                                AND ebr.deleted = 0 
                                AND ea.deleted = 0
                                AND ea.email_address = '" . $db->quote($email) . "'";
            
                    $result = $db->query($sql);
                    $idsFoundForThisEmail = [];
                    while ($row = $db->fetchByAssoc($result)) {
                        $idsFoundForThisEmail[] = $row['bean_id'];
                    }
                    if ($candidateIds === null) {
                        // Is the first email checked, the candidates are the ones we found
                        $candidateIds = $idsFoundForThisEmail;
                    } else {
                        // Already had candidates from a previous email.
                        // Do the INTERSECTION: Only use those that have THE PREVIOUS and THE CURRENT.
                        $candidateIds = array_intersect($candidateIds, $idsFoundForThisEmail);
                    }
                    // If no candidates: break loop
                    if (empty($candidateIds)) {
                        break;
                    }
                }
                // If after looking at the emails we have no candidates, this rule has failed
                if (empty($candidateIds)) {
                   continue;
                }
            }

            // Scalar duplicate check
            $foundBean = null;

            if ($candidateIds !== null) {
                // Found candidates via Email.
                // Verify if these candidates satisfy the rest of the scalar fields.
                foreach ($candidateIds as $id) {
                    $beanToCheck = BeanFactory::getBean($module, $id);
                    if ($beanToCheck) {
                        $match = true;
                        foreach ($scalarFields as $sField => $sValue) {
                            if ($beanToCheck->$sField != $sValue) {
                                $match = false;
                                break;
                            }
                        }
                        if ($match) {
                            $foundBean = $beanToCheck;
                            break; // Full match found
                        }
                    }
                }
            } else {
                // The rule did NOT have emails. Only scalar fields.
                if (!empty($scalarFields)) {
                    $tempBean = BeanFactory::newBean($module);
                    $foundBean = $tempBean->retrieve_by_string_fields($scalarFields);
                }
            }

            if ($foundBean !== null) {
                $bean = $foundBean; // Duplicate found
                $onDuplicateAction = $rule->on_duplicate;
                break; // Stop searching, we found one
            }
        }

        // Action Logic (Create or Handle Duplicate)
        $modificationType = null;
        if ($bean === null) {
            // No duplicate, create a new one
            $bean = BeanFactory::newBean($module);
            // Assign user if a default one is set
            if (!empty($context->defaultAssignedUserId)) {
                $bean->assigned_user_id = $context->defaultAssignedUserId;
            }
            // Fill all bean fields
            $this->populateBean($bean, $block); 
            $bean->save();
            $modificationType = BeanModificationType::CREATED;

        } else {
            // Duplicate found, apply the rule
            switch ($onDuplicateAction) {
                case OnDuplicateAction::ERROR:
                    // Generate an error and stop the flow
                    return new ActionResult(ResultStatus::ERROR, $actionConfig, "Duplicate record found for module {$module}.");

                case OnDuplicateAction::UPDATE:
                    // Overwrite all fields of the existing bean
                    $this->populateBean($bean, $block);
                    $bean->save();
                    $modificationType = BeanModificationType::UPDATED;
                    break;

                case OnDuplicateAction::ENRICH:
                    // Fill only empty fields of the existing bean
                    $this->enrichBean($bean, $block); 
                    $bean->save();
                    $modificationType = BeanModificationType::ENRICHED;
                    break;
                
                case OnDuplicateAction::SKIP:
                default:
                    // Do nothing, the bean remains as it was
                    $modificationType = BeanModificationType::SKIPPED;
                    break;
            }
        }

        // Logging and Return
        $actionResult = new ActionResult(ResultStatus::OK, $actionConfig);
        
        // Register the modification (or non-modification)
        $actionResult->registerBeanModificationFromBlock($bean, $block, $modificationType);

        return $actionResult;
    }

    private function isEmailField($bean, $fieldName) 
    {
        if (isset($bean->field_defs[$fieldName]) &&
            isset($bean->field_defs[$fieldName]['type']) &&
            $bean->field_defs[$fieldName]['type'] === 'email') {
            return true;
        }
        if (isset($bean->field_defs[$fieldName]) &&
            isset($bean->field_defs[$fieldName]['type']) &&
            $bean->field_defs[$fieldName]['type'] === 'varchar' && 
            isset($bean->field_defs[$fieldName]['source']) &&
            $bean->field_defs[$fieldName]['source'] === 'non-db' &&
            strpos($fieldName, 'email') !== false) {
            return true;
        }
        return false;
    }

    /**
     * Fills a bean with all form data (overwrites).
     */
    private function populateBean(SugarBean $bean, DataBlockResolved $block): void
    {
        foreach ($block->formData as $fieldName => $field) {
            if ($field != null) {
                $fieldDef = $bean->field_defs[$fieldName] ?? null;
                if ($fieldDef && isset($fieldDef['type']) && $fieldDef['type'] === 'relate' && !empty($fieldDef['id_name'])) {
                    // Relate field: we need to assign the related ID to the hidden ID field
                    $idField = $fieldDef['id_name'];
                    $bean->{$idField} = $field->value;
                } else {
                    $bean->{$fieldName} = $field->value;
                }
            }
        }
    }

    /**
     * Fills a bean only with empty fields (enriches).
     */
    private function enrichBean(SugarBean $bean, DataBlockResolved $block): void
    {
        foreach ($block->formData as $fieldName => $field) {
            // Check if the field in the bean is empty or null
            $isEmpty = ($bean->{$fieldName} === null || $bean->{$fieldName} === '');
            $fieldDef = $bean->field_defs[$fieldName] ?? null;

            // If it is a relate, check the related ID field
            if ($fieldDef && isset($fieldDef['type']) && $fieldDef['type'] === 'relate' && !empty($fieldDef['id_name'])) {
                $idField = $fieldDef['id_name'];
                $isEmpty = empty($bean->$idField);
            }

            if ($isEmpty) {
                if ($fieldDef && isset($fieldDef['type']) && $fieldDef['type'] === 'relate' && !empty($fieldDef['id_name'])) {
                    // Relate field: we need to assign the related ID to the hidden ID field
                    $idField = $fieldDef['id_name'];
                    $bean->{$idField} = $field->value;
                } else {
                    $bean->{$fieldName} = $field->value;
                }
            }
        }
    }
}
